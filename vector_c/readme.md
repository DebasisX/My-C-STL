Documentation 
-------------
(This was generated by GPT but I read through it! and yeah seems good, if you find some 
issues, feel free to reach out.)


Overview 
--------
This library provides a type-safe, high-performance vector (dynamic array) implementation 
with assembly-optimized operations for integers, doubles, and strings (char pointers). 
The vector automatically handles memory management and resizing.

Header File (vector.h)

#ifndef VECTOR_H
#define VECTOR_H

#include <stdlib.h>

typedef enum {
    TYPE_INT = 1,    // Integer vector
    TYPE_STRING,     // String vector (char*)
    TYPE_DOUBLE      // Double vector
} vec_type;

// Function pointer types
typedef void (*ins)(void*, void*);    // Insert function
typedef void (*del)(void*, int);      // Delete function
typedef int (*srch)(void*, void*);    // Search function
typedef void (*idx)(void*, int, void*); // Index function

typedef struct {
    void*    data;       // Pointer to array data
    size_t   sz;         // Current number of elements
    size_t   cap;        // Current capacity
    vec_type type;       // Type of elements
    size_t   size;       // Size of each element
    
    // Function pointers for ASM-optimized operations
    ins insert_func;
    del delete_func;
    srch search_func;
    idx index_func;
} vector;

// Core functions
void vector_init(vector* v, vec_type type);
void vector_free(vector* v);
void vector_ins(vector* v, void* value);
void vector_del(vector* v, int index);
int vector_srch(vector* v, void* value);
void vector_get(vector* v, int index, void* out);

#endif

Basic Usage
-----------
1. Initialization
vector v;
vector_init(&v, TYPE_INT);  // Create integer vector

Supported types:
---------------
TYPE_INT: Vector of integers (int)
TYPE_DOUBLE: Vector of doubles (double)
TYPE_STRING: Vector of strings (char*)

2. Inserting Elements
---------------------
int x = 42;
vector_ins(&v, &x);  // Insert integer

double d = 3.14;
vector vd;
vector_init(&vd, TYPE_DOUBLE);
vector_ins(&vd, &d);  // Insert double

char* str = "hello";
vector vs;
vector_init(&vs, TYPE_STRING);
vector_ins(&vs, &str);  // Insert string

3. Accessing Elements
---------------------
int out;
vector_get(&v, 0, &out);  // Get first element
printf("First element: %d\n", out);

4. Searching Elements
---------------------
int target = 42;
int index = vector_srch(&v, &target);
if (index != -1) {
    printf("Found at index: %d\n", index);
}

5. Deleting Elements
--------------------
vector_del(&v, 0);  // Delete first element

6. Cleanup
----------
vector_free(&v);  // Free allocated memory

Complete Example
----------------
#include "vector.h"
#include <stdio.h>

int main() {
    vector v;
    vector_init(&v, TYPE_INT);
    
    // Insert elements
    for (int i = 0; i < 10; i++) {
        vector_ins(&v, &i);
    }
    
    // Search for value
    int target = 5;
    int index = vector_srch(&v, &target);
    printf("Value %d found at index %d\n", target, index);
    
    // Access all elements
    for (size_t i = 0; i < v.sz; i++) {
        int val;
        vector_get(&v, i, &val);
        printf("%d ", val);
    }
    printf("\n");
    
    vector_free(&v);
    return 0;
}

Performance Notes
-----------------
- The vector automatically doubles its capacity when full
- All operations are optimized with assembly implementations

For best performance:
--------------------
- Pre-allocate large vectors when possible
- Use direct memory access for batch operations
- Free vectors when no longer needed

Error Handling
--------------
The library will exit the program on:
- Failed memory allocation (malloc/realloc failures)
- Unsupported vector types

Compile with:
-------------
gcc -O3 -march=native your_program.c vector.asm -o program

Limitations
-----------
- The vector stores copies of all data
		again i'll explain it, 
		- to make memory management unambiguous, the data is fully stored in th vector.
		- and no concept of dangling pointers remain.
		put simply, for performance optimizations in CP you often fail runtime not memory.
		i have optimized it mostly for int/doubles.  


- For strings, only pointers are stored (does not manage string memory)

		I'll explain it as GPT thinks we are too smart!
		"For strings, only pointers are stored"
		it means:
		when storing strings (char*), the vector only copies the pointer, not the string contents.
		Example:
		char buffer[100] = "hello";
		vector_ins(&vs, &buffer);  // stores pointer to buffer
		strcpy(buffer, "world");  // vector contains changed string

		consider this scenario:
		char* str = malloc(10);
		strcpy(str, "hello");
		vector_ins(&vs, &str);
		free(str);  // vector has dangling pointer!
		so you must manage the actual string memory yourself
		The vector won't free your strings when destroyed
		string contents can change unexpectedly if using some functions from some other library.
		there's a workaround?
		- always allocate strings with malloc before inserting
		Or implement deep copy functions
		
- Lastly, not thread-safe (requires external synchronization for concurrent access)
		in CP, you are not allowed for multithreading to pass cases.
		
This documentation covers the basic usage of the vector library. 
The assembly-optimized implementations make it particularly suitable 
for performance-critical applications requiring dynamic arrays.
